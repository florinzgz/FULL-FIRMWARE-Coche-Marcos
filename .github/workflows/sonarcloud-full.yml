name: SonarCloud Full Audit

on:
  push:  
    branches: [ "main" ]
  schedule:
    - cron: "0 3 * * 0"
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  security-events: write

jobs:
  sonarcloud:  
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name:  Cache PlatformIO
        uses: actions/cache@v3
        with:
          path: |
            ~/.platformio
            .pio
          key: ${{ runner.os }}-pio-${{ hashFiles('platformio.ini') }}

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential python3 python3-pip

      - name: Install PlatformIO
        run: |
          pip install platformio

      - name: Build all environments
        run: |
          pio run -v
          pio run --target compiledb

      - name: Verify compile_commands.json generation
        run: |
          echo "Checking for compile_commands.json files..."
          ls -lh .pio/build/*/compile_commands.json || {
            echo "Error: No compile_commands.json files found in .pio/build directories"
            echo "Contents of .pio/build:"
            ls -la .pio/build/ || echo "Directory .pio/build does not exist"
            exit 1
          }
          echo "Displaying content of found compile_commands.json files:"
          for f in .pio/build/*/compile_commands.json; do
            if [ -f "$f" ]; then
              echo "File: $f"
              echo "Size: $(wc -c < "$f") bytes"
              echo "First few lines:"
              head -20 "$f" || echo "Could not read file"
            fi
          done

      - name: Merge compilation databases
        run: |
          python3 << 'EOF'
          import json
          from pathlib import Path
          
          # Find all compile_commands.json files in .pio/build directories
          build_dir = Path('.pio/build')
          compile_db_files = list(build_dir.glob('*/compile_commands.json'))
          
          if not compile_db_files: 
              print("Error: No compile_commands.json files found in any build environment")
              exit(1)
          
          print(f"Found {len(compile_db_files)} compilation database(s):")
          for f in compile_db_files:
              print(f"  - {f}")
          
          # Merge all compilation databases
          merged_commands = []
          for db_file in compile_db_files:
              try:
                  with open(db_file, 'r') as f:
                      commands = json.load(f)
                      merged_commands.extend(commands)
                      print(f"Merged {len(commands)} commands from {db_file}")
              except Exception as e:
                  print(f"Warning: Failed to read {db_file}: {e}")
          
          if not merged_commands:
              print("Error:  No compilation commands found in any database")
              exit(1)
          
          # Write merged database to root
          output_file = 'compile_commands.json'
          with open(output_file, 'w') as f:
              json.dump(merged_commands, f, indent=2)
          
          print(f"\nSuccessfully created {output_file} with {len(merged_commands)} compilation commands")
          
          # Show sample entries for verification
          if merged_commands:
              print("\nSample compilation commands:")
              for i, cmd in enumerate(merged_commands[:3]):
                  print(f"\n  Entry {i+1}:")
                  print(f"    File: {cmd.get('file', 'N/A')}")
                  print(f"    Directory: {cmd.get('directory', 'N/A')}")
          EOF

      - name: Fix compilation database paths
        run: |
          python3 << 'EOF'
          import json
          import os
          from pathlib import Path
          
          # Read merged compile_commands.json
          with open('compile_commands.json', 'r') as f:
              commands = json.load(f)
          
          # Fix paths to point to original source files
          fixed_commands = []
          for cmd in commands:
              # Get the file path
              file_path = cmd.get('file', '')
              
              # If file is in .pio/build, find corresponding source file
              if '.pio' in file_path: 
                  # Extract relative path from .pio/build/xxx/src/...  or .pio/build/xxx/include/...
                  parts = Path(file_path).parts
                  try:
                      # Find 'src' or 'include' in path
                      if 'src' in parts:
                          src_idx = parts.index('src')
                          rel_path = Path(*parts[src_idx:])
                          cmd['file'] = str(rel_path)
                      elif 'include' in parts:
                          inc_idx = parts.index('include')
                          rel_path = Path(*parts[inc_idx:])
                          cmd['file'] = str(rel_path)
                      
                      # Update directory to project root
                      cmd['directory'] = os.getcwd()
                  except (ValueError, IndexError):
                      pass  # Keep original if parsing fails
              
              fixed_commands.append(cmd)
          
          # Write fixed database
          with open('compile_commands.json', 'w') as f:
              json.dump(fixed_commands, f, indent=2)
          
          print(f"✓ Fixed paths in compile_commands.json ({len(fixed_commands)} entries)")
          
          # Show sample of fixed paths for verification
          if fixed_commands:
              print("\nSample fixed paths:")
              for cmd in fixed_commands[:3]: 
                  print(f"  - {cmd.get('file', 'N/A')}")
          EOF

      - name: Verify compilation database
        run: |
          if [ ! -f compile_commands.json ]; then
            echo "Error: compile_commands.json not found at repository root"
            exit 1
          fi
          
          # Verify it's valid JSON and has content
          python3 << 'EOF'
          import json
          try:
              with open('compile_commands.json', 'r') as f:
                  data = json.load(f)
              if len(data) == 0:
                  print("Error: compile_commands.json is empty")
                  exit(1)
          except json.JSONDecodeError as e:
              print(f"Error: compile_commands.json is invalid JSON: {e}")
              exit(1)
          except Exception as e:
              print(f"Error: Failed to validate compile_commands.json: {e}")
              exit(1)
          EOF
          
          echo "✓ compile_commands.json verified successfully"
          python3 -c "import json; print(f'  Contains {len(json.load(open(\"compile_commands.json\")))} compilation commands')"

      - name: SonarCloud Scan
        uses: sonarsource/sonarcloud-github-action@v2
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          args: >
            -Dsonar.projectKey=florinzgz_FULL-FIRMWARE-Coche-Marcos
            -Dsonar.organization=florinzgz
            -Dsonar.projectBaseDir=. 
            -Dsonar.sources=src,include
            -Dsonar.exclusions=.pio/**,lib/**,test/**
            -Dsonar.cfamily.compile-commands=compile_commands.json
            -Dsonar.cfamily.cache.enabled=false
            -Dsonar.verbose=true
            -Dsonar.qualitygate.wait=true
