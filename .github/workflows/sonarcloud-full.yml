name: SonarCloud Full Audit

on:
  push:  
    branches: [ "main" ]
  schedule:
    - cron: "0 3 * * 0"
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  security-events: write

jobs:
  sonarcloud:  
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Cache PlatformIO
        uses: actions/cache@v3
        with:
          path: |
            ~/.platformio
            .pio
          key: ${{ runner.os }}-pio-${{ hashFiles('platformio.ini') }}

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential python3 python3-pip

      - name: Install PlatformIO
        run: |
          pip install platformio

      - name: Build all environments
        run: |
          pio run -v
          pio run --target compiledb

      - name: Verify compile_commands.json generation
        run: |
          echo "Checking for compile_commands.json files..."
          ls -lh .pio/build/*/compile_commands.json || {
            echo "Error: No compile_commands.json files found in .pio/build directories"
            echo "Contents of .pio/build:"
            ls -la .pio/build/ || echo "Directory .pio/build does not exist"
            exit 1
          }
          echo "Displaying content of found compile_commands.json files:"
          for f in .pio/build/*/compile_commands.json; do
            if [ -f "$f" ]; then
              echo "File: $f"
              echo "Size: $(wc -c < "$f") bytes"
              echo "First few lines:"
              head -20 "$f" || echo "Could not read file"
            fi
          done

      - name: Merge compilation databases
        run: |
          python3 << 'EOF'
          import json
          from pathlib import Path
          import os
          
          # Find all compile_commands.json files in .pio/build directories
          build_dir = Path('.pio/build')
          compile_db_files = list(build_dir.glob('*/compile_commands.json'))
          
          if not compile_db_files: 
              print("Error: No compile_commands.json files found in any build environment")
              exit(1)
          
          print(f"Found {len(compile_db_files)} compilation database(s):")
          for f in compile_db_files:
              print(f"  - {f}")
          
          # Merge and filter compilation databases
          merged_commands = []
          project_root = Path.cwd()
          
          for db_file in compile_db_files:
              try:
                  with open(db_file, 'r') as f:
                      commands = json.load(f)
                      
                  # Filter to include only files from src/ or include/ directories
                  for cmd in commands:
                      file_path = Path(cmd.get('file', ''))
                      
                      # Check if file is from project source directories
                      # Look for files that contain 'src/' or 'include/' in their build path
                      file_str = str(file_path)
                      
                      # Match files that were compiled from our source directories
                      # Pattern: .pio/build/env_name/src/... or actual src/... or include/...
                      if '/src/' in file_str or '/include/' in file_str:
                          # Try to extract the relative path from src/ or include/
                          parts = file_path.parts
                          
                          try:
                              # Find where src or include starts
                              if 'src' in parts:
                                  idx = len(parts) - 1 - parts[::-1].index('src')
                                  rel_path = Path(*parts[idx:])
                              elif 'include' in parts:
                                  idx = len(parts) - 1 - parts[::-1].index('include')
                                  rel_path = Path(*parts[idx:])
                              else:
                                  continue
                              
                              # Check if this file exists in our project
                              actual_file = project_root / rel_path
                              if actual_file.exists():
                                  # Update command with corrected paths
                                  cmd['file'] = str(rel_path)
                                  cmd['directory'] = str(project_root)
                                  merged_commands.append(cmd)
                                  print(f"  ✓ Included: {rel_path}")
                              
                          except (ValueError, IndexError):
                              continue
                              
                  print(f"Processed {db_file}: found {len([c for c in merged_commands])} project files")
                  
              except Exception as e:
                  print(f"Warning: Failed to read {db_file}: {e}")
          
          if not merged_commands:
              print("Error: No compilation commands found for project source files in src/ or include/")
              print("Make sure your project has .cpp or .c files in src/ directory")
              exit(1)
          
          # Remove duplicates based on file path
          unique_commands = {}
          for cmd in merged_commands:
              file_path = cmd.get('file')
              if file_path not in unique_commands:
                  unique_commands[file_path] = cmd
          
          final_commands = list(unique_commands.values())
          
          # Write filtered database to root
          output_file = 'compile_commands.json'
          with open(output_file, 'w') as f:
              json.dump(final_commands, f, indent=2)
          
          print(f"\n✓ Successfully created {output_file} with {len(final_commands)} project compilation commands")
          
          # Show all entries for verification
          if final_commands:
              print("\nFiles included in compilation database:")
              for cmd in final_commands:
                  print(f"  - {cmd.get('file', 'N/A')}")
          EOF

      - name: Verify compilation database
        run: |
          if [ ! -f compile_commands.json ]; then
            echo "Error: compile_commands.json not found at repository root"
            exit 1
          fi
          
          # Verify it's valid JSON and has content
          python3 << 'EOF'
          import json
          try:
              with open('compile_commands.json', 'r') as f:
                  data = json.load(f)
              if len(data) == 0:
                  print("Error: compile_commands.json is empty")
                  exit(1)
          except json.JSONDecodeError as e:
              print(f"Error: compile_commands.json is invalid JSON: {e}")
              exit(1)
          except Exception as e:
              print(f"Error: Failed to validate compile_commands.json: {e}")
              exit(1)
          EOF
          
          echo "✓ compile_commands.json verified successfully"
          python3 -c "import json; print(f'  Contains {len(json.load(open(\"compile_commands.json\")))} compilation commands')"

      - name: SonarCloud Scan
        uses: sonarsource/sonarcloud-github-action@v2
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          args: >
            -Dsonar.projectKey=florinzgz_FULL-FIRMWARE-Coche-Marcos
            -Dsonar.organization=florinzgz
            -Dsonar.projectBaseDir=.
            -Dsonar.sources=src,include
            -Dsonar.exclusions=.pio/**,lib/**,test/**
            -Dsonar.cfamily.compile-commands=compile_commands.json
            -Dsonar.cfamily.cache.enabled=false
            -Dsonar.verbose=true
            -Dsonar.qualitygate.wait=true
